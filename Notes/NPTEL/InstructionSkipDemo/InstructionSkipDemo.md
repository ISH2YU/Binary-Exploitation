### InstructionSkipDemo

```sh
gcc -fno-stack-protector -z execstack -no-pie -m32 -g code.c -o code
```

Try to guess the output of the code, one might think that the output will be `1` but lets look at it
Run the program and what we see is that the value of executable is `0`

Infact the instruction `x=1;` has not been executed at all

We can set a breakpoint just before the function() is called them rim the program in gdb

In gdb we can check the value of the varibale `x` using the command
`info locals` and it is `0` at the moment

![alt text](local&reg.png)

Before calling the function() we first have to push the parameters onto the stack and as we can see the `eip` pointing at address of `push 0x3`

Lets step into function() using `si`
And `si 4` inside function() so that stack frame is set

![alt text](check.png)

We can see that the return address is stored in stack at the address
`0xffffce4c + 4` that is at the address `0xffffce50`

In this function we have 2 locals, pointer to an integer `ret` and a buffer which is of 16 characters

The values of variables are

```sh
ppwndbg> p/x &ret
$1 = 0xffffce48
pwndbg> p/x &buffer
$2 = 0xffffce38
```

We can see that contents of buffer start at `0xffffce38` and extends for 16 bytes, anything beyond these 16 bytes would lead to a buffer overflow

Now we want to overflow the buffer in such a way that return address is modified
We can calculate the difference between the buffer's base address and return address location

We know that return address is at location `0xffffce50`
and buffer is present at location `0xffffce38`

Subtract 0xffffce50 - 0xffffce38 = 18 in hex and 24 in decimal
so 24 bytes from start of buffer to the return address

In C code we can see that

```c
ret=(int *)(buffer+24)
(*ret)+=8;
```

So the `ret` variable essentially stores the return address of function()

We can go to the instruction and print the value of variable `ret`

![alt text](check1.png)

We can see that `ret` now contains the address `0xffffce50` which is the address where return address is stored or the address that points to return address

We can examine the value in at the address `0xffffce50` using the command

```sh
x *ret
```

We can see in the image below that where the return address points to

![alt text](check2.png)

And it is same as the return address of

Next line in c code increments the value of `ret` by 8 bytes

![alt text](check3.png)

We can see that return address is now previous return address+8
So we have jumped a few instructions
So the part of code where the value of variable `x` is being changed to `1` is being skipped so thats why when we run program, value of variable `x` dosent change
