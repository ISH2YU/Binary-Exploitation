### Buffer overflow and ShellCode Injection

```c
char buffer[100];
strcpy(buffer,str);
```

strcpy will continues to copy until it encounters '\0' or null character so we can get a buffer over flow here
Vulnerablity comes due to `strcpy`
If `strcpy` dosent encounter '\0' null character it will continue to copy even if it exceeds 100 bytes

```sh
gcc -fno-stack-protector -z execstack -no-pie -m32 -g code.c -o code
```

If we run the program with larger value that 100 bytes lets see what happens

```sh
./code AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

zsh: segmentation fault (core dumped)  ./code
```

We get segmentation fault
Lets investigate what causes this segmentation fault for that we will use gdb

Put 2 breakpoints, 1 where copier() function is called and 1 on the line just after `strcpy` has been executed

The first breakpoint will be hit when `strcpy` has just finished execution
Lets check the registers now

```sh
info registers eip esp ebp
```

![alt text](reg1.png)

We can see that `eip` and `ebp` contain `0x41414141` which is hexadecimal representation of `A` so our input is now in EIP

Press `n` in gdb to execute next instruction
And we get an error saying

```ascii
Invalid address 0x41414141
```

So the machine is trying to access the data at address `0x41414141` which was supplied by the user

Lets look at the contents of the stack

```sh
x/32x $esp
```

![alt text](stack1.png)

We can see that every address location including the return addreess is filled with `0x41414141` which is `A` in hexa and was our input

When copier() functions tries to return it picks return address from the stack but the return address has been corrupted with user input

So now `eip` will have the value `0x41414141` which is an invalid memory address
Since the return address is invalid the program results in segmentation fault

We can confirm that it is an invalid address by examinig the value at that address using the command

```sh
pwndbg> x *0x41414141
Cannot access memory at address 0x41414141
```

Now we are going to perform shellcode injection attack to get a shell

For this we need to identify at which point the program stops working or at how many bytes of input the program crashes

For that we can use pwntools library for python
You can install it using

```sh
pip3 install pwntools
```

To generate a cyclic pattern do

```sh
cyclic 200
```

In gdb do this

```sh
r aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
```

Press `c` 2 times to continue over breakpoint then look at the registers

![alt text](reg2.png)

We can see the data that has entered `eip` is `daab`, to find the offset just run

```sh
cyclic -l daab
```

And we get the offset is at `112` bytes

So the 4 bytes after the 112 bytes will enter into the EIP

We can manually check it as well,
100 bytes of buffer + 4 bytes for the varible + 4 bytes for the ebp
Minimum we need 108 bytes to cause segmentation fault because, first 4 bytes for the variable and the next 4 bytes after the 104 bytes will reach the `ebp` and corrupt it

The code will print `Done` then we wil get segmentation fault because main() will execute but will not be able to exit cleanly

When we supply 112 bytes, `Done` wont execute as well since copier() functions return address has been corrupted

We want the return address of the shellcode we are injecting

We supply bunch of `nop` then we provide our shellcode then we need to jump to one of the `nop` we supplied and after that our shellcode is present which will be executed

```sh
r $(cat payload)
```

So we push our payload onto the stack and jump to it to execute it
