Format String Vulnerabilities
Problem : printf not specifying what data type it is printing 
Anythime we are taking data from user and printing it with printf, we need to spcify type of data

like printf("%d",a) for printing integer variable named 'a'
%s, %i

If we are attacking remote server, we dont know address of libc and other things like system() function and /bin/sh
so we would need to check if libc address is being leaked somewhere or we can do Format string vulnerabilities

We can do format string vulnerabilites to leak things from stack

# sudo chown root:root flag.txt
# sudo chown root:root format_vuln
# sudo chmod 4655 format_vuln 
# sudo chmod 600 flag.txt

    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)


Using fgets() so vulnerability of overflow 
Might not look vulnerable but problem is printf

if we dont specify the format of output, the attacker can do that instead

try to input format specifiers like %x, %d
> %x %x %x
40 f7e1e620 8049217

> %p %p %p %p %p %p %p
0x40 0xf7e1e620 0x8049217 (nil) 0x67616c66 0x526f667b 0x5f74346d

% p : for pointer
%x  : for hex

Checkthe output : 0x67616c66 : this looks like ascii
# unhex 67616c66
= galf  = flag in reverse coz of litte endian

# unhex 666c6167
= flag

*****
What we are doing is that we are leaking addresses of the stack 
We can also leak libc address in this way
*****

******to print the 10th element of stack and print it as hex 
# %10$x

**********
%s is different
When we do %x, we are printing the values present in stack as hex
when we do %s its not printing the value on stack as string,it is treating it as a pointer so it is going to go to that location and print the string present there
**********

# %p = 0x40
# %s = treat 0x40 as a pointer(it is not a valid address since we are in 32 bit) and going to that address to print the string present at that address

> %s
zsh: segmentation fault (core dumped)  ./format_vuln

So we get segmentation fault we we do %s since 0x40 is not a valid address

So if we are trying to do %s, we need to run program again everytime after getting output or segmentation fault

What we can do is give an input an address and it will be pushed onto the stack then we can do %s to tell it to go and check what is present at the address provided

%n : can use it to write values

In exploit.py, each time process is started again coz we are doing %s and it is bound to give segmentation fault if we access an invalid memory address

Run the script and we get 100 responses

37: b'\x98$\xad\xfb\xe0b\x15\t\xe0b\x15\t\xe0b\x15\t\xe0b\x15\t\xe0b\x15\t\xe0b\x15\t\xe0b\x15\t\xe0r\x15\t\n> '
39: b'flag{foRm4t_stRinGs_aRe_DanGer0us}\n> '
40: b'\x01\n> '
41: b'\x8c\xdd!\n> '

one of ewhich contains flag

we even got some environmental variables
93: b'/home/jeetu855/CryptoCat/pwn/binary_exploitation_101/07-format_string_vulns/format_vuln\n> '
94: b'(null)\n> '
95: b'TERMINATOR_DBUS_NAME=net.tenshu.Terminator21a9d5db22c73a993ff0b42f64b396873\n> '
96: b'SSH_AUTH_SOCK=/tmp/ssh-nmcbZQLdBRy7/agent.1671\n> '
97: b'LANGUAGE=en_IN:en\n> '
98: b'LANG=en_IN\n> 


**
We can recompile the binary for 64 bit and re run the same script and it will work coz context.binary is set

# gcc format_vuln.c -o format_vuln64 -no-pie -fno-stack-protector

# sudo chown root:root format_vuln64
# sudo chmod 4655 format_vuln64 

# python3 fuzz64.py
25: b'\x98$\xad\xfb\n> '
27: b'flag{foRm4t_stRinGs_aRe_DanGer0us}\n> '
29: b'\x89\xc7\xe8\x9fs\x01\n> 





*******
We can do %p %p until we get an value that looks like proper address, then we can go into gdb and check if it is part of libc

If yes, we can then find its offset and just subtract it from the value we got to get base address of libc and do    libc attack again


